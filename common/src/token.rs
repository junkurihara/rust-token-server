use crate::{
  token_fields::*,
  validation_key::{Claims, ValidationKey, ValidationOptions},
};
use anyhow::{anyhow, bail, Result};
use base64::Engine;
use chrono::{DateTime, TimeZone, Utc};
use jwt_compact::{self, UntrustedToken};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashSet;
pub use tracing::debug;

#[derive(Serialize, Deserialize, Debug, Clone)]
/// Token body
pub struct TokenBody {
  /// id_token jwt itself is given here as string
  pub id: IdToken, //String,
  /// refresh token if required
  pub refresh: Option<RefreshToken>,
  /// issued at in unix time
  pub issued_at: String,
  /// expires in unix time
  pub expires: String,
  /// allowed apps, i.e, client_ids
  pub allowed_apps: Audiences,
  /// issuer specified by url like 'https://example.com/' for IdToken
  pub issuer: Issuer,
  /// subscriber id generated by the token server
  pub subscriber_id: SubscriberId,
}

impl TokenBody {
  /// Decode id token and retrieve metadata
  pub fn decode_id_token(&self) -> Result<UntrustedToken> {
    // Token::decode_metadata(&self.id).map_err(|e| AuthError::FailedToDecodeIdToken(e).into())
    Ok(UntrustedToken::new(self.id.as_str())?)
  }

  /// Verify id token with key string
  pub async fn verify_id_token(&self, validation_key: &ValidationKey, client_id: &str, token_api: &str) -> Result<Claims> {
    let options = ValidationOptions {
      allowed_audiences: Some(Audiences::new(client_id)?),
      allowed_issuers: Some(HashSet::from([Issuer::new(token_api)?])),
      ..Default::default()
    };

    let res = validation_key.validate(&self.id, &options)?;

    Ok(res)
  }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
/// Token metadata
pub struct TokenMeta {
  pub username: String,
  pub is_admin: bool,
}

impl TokenBody {
  pub fn new(id_token: &IdToken, refresh_required: bool) -> Result<Self> {
    // get token info
    let parsed: Vec<&str> = id_token.as_str().split('.').collect();
    let decoded_claims =
      base64::engine::GeneralPurpose::new(&base64::alphabet::URL_SAFE, base64::engine::general_purpose::NO_PAD)
        .decode(parsed[1])?;
    let json_string = String::from_utf8(decoded_claims)?;
    let json_value: Value = serde_json::from_str(&json_string).map_err(|e| anyhow!("{}", e))?;

    let Some(subscriber_id) = json_value["sub"].as_str() else {
      bail!("No issuer is specified in JWT");
    };
    let iat = json_value["iat"].to_string().parse::<i64>()?;
    let exp = json_value["exp"].to_string().parse::<i64>()?;
    let Some(iss) = json_value["iss"].as_str() else {
      bail!("No issuer is specified in JWT");
    };
    let aud = if let Value::Array(aud_vec) = &json_value["aud"] {
      let iter = aud_vec
        .iter()
        .filter_map(|x| x.as_str())
        .map(ClientId::new)
        .filter_map(|v| v.ok());
      Audiences::from(iter)
    } else {
      Audiences::new("")?
    };
    let issued_at: DateTime<Utc> = Utc.timestamp_opt(iat, 0).unwrap();
    let expires: DateTime<Utc> = Utc.timestamp_opt(exp, 0).unwrap();

    let refresh: Option<RefreshToken> = if refresh_required {
      debug!("[{subscriber_id}] Create refresh token");
      Some(RefreshToken::generate()?)
    } else {
      None
    };

    Ok(Self {
      id: id_token.to_owned(),
      refresh,
      issuer: Issuer::new(iss)?,
      allowed_apps: aud,
      issued_at: issued_at.to_string(),
      expires: expires.to_string(),
      subscriber_id: SubscriberId::new(subscriber_id)?,
    })
  }
}

#[cfg(test)]
mod tests {
  use crate::constants::REFRESH_TOKEN_LEN;

  use super::*;

  #[test]
  fn test_token_inner() {
    let test_vector = IdToken::new("eyJhbGciOiJFZERTQSIsImtpZCI6ImdqckU3QUNNeGd6WWZGSGdhYmdmNGtMVGcxZUtJZHNKOTRBaUZURmoxaXMiLCJ0eXAiOiJKV1QifQ.eyJpYXQiOjE2ODA3MDM2MzAsImV4cCI6MTY4MDcwNTQzMCwibmJmIjoxNjgwNzAzNjMwLCJpc3MiOiJodHRwczovL2F1dGguZXhhbXBsZS5jb20vdjEuMCIsInN1YiI6IjY5ZjUwZmZiLTM1NTYtNDQ2ZS05YTMwLWFmODZhMmE2NjAwNyIsImF1ZCI6WyJjbGllbnRfaWQxIl0sImlzX2FkbWluIjp0cnVlfQ.afZPBq5405DUehIPP6EG2psDPOMngOuZzT-ySPraJFTTJT0TDoaa3hzAS_Ug_UXSPsxYGmZnrVBBgA4TEfTHCQ").unwrap();

    let token_inner = TokenBody::new(&test_vector, true).expect("Token inner is invalid");
    assert!(token_inner.refresh.is_some());
    assert_eq!(&token_inner.issued_at, "2023-04-05 14:07:10 UTC");
    assert_eq!(&token_inner.expires, "2023-04-05 14:37:10 UTC");
    assert_eq!(token_inner.allowed_apps, Audiences::new("client_id1").unwrap());
    assert_eq!(token_inner.issuer.as_str(), "https://auth.example.com/v1.0");
    assert_eq!(token_inner.subscriber_id.as_str(), "69f50ffb-3556-446e-9a30-af86a2a66007");

    let token_inner = TokenBody::new(&test_vector, false).expect("Token inner is invalid");
    assert!(token_inner.refresh.is_none());
    assert_eq!(&token_inner.issued_at, "2023-04-05 14:07:10 UTC");
    assert_eq!(&token_inner.expires, "2023-04-05 14:37:10 UTC");
    assert_eq!(token_inner.allowed_apps, Audiences::new("client_id1".to_string()).unwrap());
    assert_eq!(token_inner.issuer.as_str(), "https://auth.example.com/v1.0");
    assert_eq!(token_inner.subscriber_id.as_str(), "69f50ffb-3556-446e-9a30-af86a2a66007");
  }

  #[test]
  fn test_token_meta() {
    let username = "test_user".to_string();
    let is_admin = false;
    let token_meta = TokenMeta { username, is_admin };
    assert_eq!(token_meta.username.as_str(), "test_user");
    assert!(!token_meta.is_admin);
  }
  #[test]
  fn test_refresh() {
    let refresh = RefreshToken::generate().expect("Refresh token creation failed");
    assert_eq!(refresh.as_str().len(), REFRESH_TOKEN_LEN as usize);
  }
}
