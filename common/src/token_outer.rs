use crate::{
  token_fields::*,
  validation_key::{Claims, ValidationKey, ValidationOptions},
};
use anyhow::Result;
use jwt_compact::{self, UntrustedToken};
use serde::{Deserialize, Serialize};
use std::collections::HashSet;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TokenOuter {
  /// id_token jwt itself is given here as string
  pub id: IdToken, //String,
  /// refresh token if required
  pub refresh: Option<RefreshToken>,
  /// issued at in unix time
  pub issued_at: String,
  /// expires in unix time
  pub expires: String,
  /// allowed apps, i.e, client_ids
  pub allowed_apps: Audiences,
  /// issuer specified by url like 'https://example.com/' for IdToken
  pub issuer: Issuer,
  /// subscriber id generated by the token server
  pub subscriber_id: SubscriberId,
}

impl TokenOuter {
  /// Decode id token and retrieve metadata
  pub fn decode_id_token(&self) -> Result<UntrustedToken> {
    // Token::decode_metadata(&self.id).map_err(|e| AuthError::FailedToDecodeIdToken(e).into())
    Ok(UntrustedToken::new(self.id.as_str())?)
  }

  /// Verify id token with key string
  pub async fn verify_id_token(
    &self,
    validation_key: &ValidationKey,
    client_id: &str,
    token_api: &str,
  ) -> Result<Claims> {
    let options = ValidationOptions {
      allowed_audiences: Some(HashSet::from([client_id.into()])),
      allowed_issuers: Some(HashSet::from([token_api.into()])),
      ..Default::default()
    };

    let res = validation_key.validate(self.id.as_str(), &options)?;

    Ok(res)
  }
}

#[derive(Deserialize, Debug, Clone)]
pub struct TokenMeta {
  pub username: String,
  pub is_admin: bool,
}
