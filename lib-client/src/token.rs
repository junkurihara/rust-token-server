use crate::{error::*, log::*, AuthenticationConfig};
use jwt_simple::{
  prelude::*,
  token::{Token, TokenMetadata},
};
use serde::Deserialize;
use std::str::FromStr;

#[derive(Debug)]
pub enum Algorithm {
  ES256,
  Ed25519,
}
impl FromStr for Algorithm {
  type Err = anyhow::Error;
  /// from "alg" string in a JWT
  fn from_str(s: &str) -> Result<Self> {
    match s {
      "ES256" => Ok(Algorithm::ES256),
      "EdDSA" => Ok(Algorithm::Ed25519),
      _ => Err(AuthError::UnsupportedAlg.into()),
    }
  }
}

#[derive(Debug, Clone)]
pub enum VerificationKeyType {
  ES256(ES256PublicKey),
  Ed25519(Ed25519PublicKey),
}

#[derive(Deserialize, Debug, Clone)]
pub struct TokenInner {
  /// id_token jwt itself is given here as string
  pub id: String,
  /// refresh token if required
  pub refresh: Option<String>,
  /// issued at in unix time
  pub issued_at: String,
  /// expires in unix time
  pub expires: String,
  /// allowed apps, i.e, client_ids
  pub allowed_apps: Vec<String>,
  /// issuer specified by url like 'https://example.com/' for IdToken
  pub issuer: String,
  /// subscriber id generated by the token server
  pub subscriber_id: String,
}

#[derive(Deserialize, Debug, Clone)]
pub struct TokenMeta {
  pub username: String,
  pub is_admin: bool,
}

impl TokenInner {
  /// Decode id token and retrieve metadata
  pub async fn decode_id_token(&self) -> Result<TokenMetadata> {
    Token::decode_metadata(&self.id).map_err(|e| AuthError::FailedToDecodeIdToken(e).into())
  }

  /// Verify id token with key string
  pub async fn verify_id_token(
    &self,
    validation_key: &VerificationKeyType,
    config: &AuthenticationConfig,
  ) -> Result<JWTClaims<NoCustomClaims>> {
    let meta = self.decode_id_token().await?;

    let options = VerificationOptions {
      accept_future: true, // accept future
      allowed_audiences: Some(HashSet::from_strings(&[&config.client_id])),
      allowed_issuers: Some(HashSet::from_strings(&[&config.token_api])),
      ..Default::default()
    };

    let clm: JWTClaims<NoCustomClaims> = match Algorithm::from_str(meta.algorithm())? {
      Algorithm::ES256 => {
        debug!("Verifying ES256");
        let VerificationKeyType::ES256(key) = validation_key else {
          bail!(AuthError::InconsistentKtyAndAlg);
        };
        key.verify_token::<NoCustomClaims>(&self.id, Some(options))?
      }
      Algorithm::Ed25519 => {
        debug!("Verifying Ed25519");
        let VerificationKeyType::Ed25519(key) = validation_key else {
          bail!(AuthError::InconsistentKtyAndAlg);
        };
        key.verify_token::<NoCustomClaims>(&self.id, Some(options))?
      }
    };

    Ok(clm)
  }
}
